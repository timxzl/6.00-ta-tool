import os
import os.path
import re
import magic
import zipfile
import rarfile

FILE_NAME_RE = '^([^@]+@[^@]+)\.([0-9]+)(\.[a-zA-Z0-9]+)?$'
FILE_NAME_MATCHER = re.compile(FILE_NAME_RE)
FileType = magic.Magic()
USED_ARCHIVE_DIR = '__inflated_archive_files'

OSX_JUNKS = ['__MACOSX', '.DS_Store']
OSX_JUNK_DIR = '__purged_osx_junks'

def init():
    ensure_dir(USED_ARCHIVE_DIR, OSX_JUNK_DIR)

def split_file_name(name):
    """
    split a file name to three parts [email, version, extension]
    """
    matched = FILE_NAME_MATCHER.match(name)
    if matched:
        return matched.group(1, 2, 3)
    else:
        print 'Malformed file name', name
        return None

def ensure_dir(*dirs):
    """
    ensures that all the directories in dirs are created if not already exist
    if you have two directories "a" and "a/b" you want to ensure
    you must specify "a" before "a/b"
    """
    for directory in dirs:
        if not os.path.exists(directory):
            os.makedirs(directory)

def ensure_path(*paths):
    for path in paths:
        d = os.path.dirname(path)
        if len(d)>0 and d!=path:
            ensure_path(d)
        ensure_dir(path)

def move_txt_file(name):
    # split name to [email, version, extension]
    file_info = split_file_name(name)
    if file_info == None:
        return None
##    print file_info
    # create path email/version
    new_dir = os.path.join(file_info[0], file_info[1])
    new_path = os.path.join(new_dir, name)
    ensure_dir(file_info[0], new_dir)
    os.rename(name, new_path)
    return new_dir

def move_archive_file(name, archive):
    """
    extract all the contents of file "name" to email/version/
    move the file "name" to USED_ARCHIVE_DIR
    archive is a class to instantiate the zip/rar file object
    """
    # split name to [email, version, extension]
    file_info = split_file_name(name)
    if file_info == None:
        return None
    new_dir = os.path.join(file_info[0], file_info[1])
    ensure_dir(file_info[0], new_dir)
    zfile = archive(name)
    zfile.extractall(new_dir)
    new_path = os.path.join(USED_ARCHIVE_DIR, name)
##    print 'moving', name, 'to', new_path
    os.rename(name, new_path)
    return new_dir

def move_file(name):
    file_type = FileType.from_file(name)
##    print 'Moving', name, file_type
    if file_type == 'directory':
        #silently ignore
##        print name, 'is a directory, ignore it'
        return None

    if file_type.startswith('ASCII text') or file_type.startswith('Python script') or file_type.startswith('FORTRAN program'):
        return move_txt_file(name)
    elif file_type.startswith('Zip archive data'):
        return move_archive_file(name, zipfile.ZipFile)
    elif file_type.startswith('RAR archive data'):
        return move_archive_file(name, rarfile.RarFile)
    else:
        print name,'has wrong file type:', file_type
        return None

def move_all():
    """
    move all the files in current directory
    """
    moved = []
    notmoved = []
    for f in os.listdir('.'):
        result = move_file(f)
        if result != None:
            moved.append(result)
        else:
            notmoved.append(f)
    return [moved, notmoved]

def purge_osx_junks(root):
    """
    clean the junks generated by Mac OS X filesystem
    """
    for path, dirs, files in os.walk(root):
        if path.startswith('./'):
            path = path[2:]
        if path.find(OSX_JUNK_DIR) >= 0 or path.find(USED_ARCHIVE_DIR)>=0:
            continue
        purged_dir = os.path.join(OSX_JUNK_DIR, path)
        ensured = False
        for f in files+dirs:
            if f in OSX_JUNKS:
                oldpath = os.path.join(path, f)
                newpath = os.path.join(purged_dir, f)
                print oldpath, '->', newpath
                if not ensured:
                    ensure_path(purged_dir)
                    ensured = True
                os.rename(oldpath, newpath)

def flattern_dir(root):
    """
    for any directory, if it only contains a subdir and no files
    flattern it, move all the entries in the only subdir to the parent
    recursively does this
    """
    for path, dirs, files in os.walk(root):
        if path.startswith('./'):
            path = path[2:]
        if path.find(OSX_JUNK_DIR) >= 0 or path.find(USED_ARCHIVE_DIR)>=0:
            continue
        if len(files)==0 and len(dirs)==1:
            subdir = os.path.join(path, dirs[0])
            for f in os.listdir(subdir):
                oldpath = os.path.join(subdir, f)
                newpath = os.path.join(path, f)
                print oldpath, '->', newpath
                os.rename(oldpath, newpath)
            print 'rmdir', subdir
            os.rmdir(subdir)
