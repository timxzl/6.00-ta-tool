import os
import os.path
import re
import magic
import zipfile
import rarfile

FILE_NAME_RE = '^([^@]+@[^@]+)\.([0-9]+)(\.[a-zA-Z0-9]+)?$'
FILE_NAME_MATCHER = re.compile(FILE_NAME_RE)
FileType = magic.Magic()
USED_ARCHIVE_DIR = '__inflated_archive_files'

OSX_JUNKS = ['__MACOSX', '.DS_Store']
OSX_JUNK_DIR = '__purged_osx_junks'

def sample_script():
    init()
    moved, notmoved = move_all()
    print 'not moved:', notmoved
    raw_input('Please check the not moved')
    purge_osx_junks('.')
    for f in moved:
        flattern_dir(f)

def init():
    ensure_dir(USED_ARCHIVE_DIR, OSX_JUNK_DIR)

def split_file_name(name):
    """
    split a file name to three parts [email, version, extension]
    """
    matched = FILE_NAME_MATCHER.match(name)
    if matched:
        return matched.group(1, 2, 3)
    else:
        print 'Malformed file name', name
        return None

def ensure_dir(*dirs):
    """
    ensures that all the directories in dirs are created if not already exist
    if you have two directories "a" and "a/b" you want to ensure
    you must specify "a" before "a/b"
    """
    for directory in dirs:
        if not os.path.exists(directory):
            os.makedirs(directory)

def ensure_path(*paths):
    for path in paths:
        d = os.path.dirname(path)
        if len(d)>0 and d!=path:
            ensure_path(d)
        ensure_dir(path)

def move_txt_file(name):
    # split name to [email, version, extension]
    file_info = split_file_name(name)
    if file_info == None:
        return None
##    print file_info
    # create path email/version
    new_dir = os.path.join(file_info[0], file_info[1])
    new_path = os.path.join(new_dir, name)
    ensure_dir(file_info[0], new_dir)
    os.rename(name, new_path)
    return new_dir

def move_archive_file(name, archive):
    """
    extract all the contents of file "name" to email/version/
    move the file "name" to USED_ARCHIVE_DIR
    archive is a class to instantiate the zip/rar file object
    """
    # split name to [email, version, extension]
    file_info = split_file_name(name)
    if file_info == None:
        return None
    new_dir = os.path.join(file_info[0], file_info[1])
    ensure_dir(file_info[0], new_dir)
    zfile = archive(name)
    zfile.extractall(new_dir)
    new_path = os.path.join(USED_ARCHIVE_DIR, name)
##    print 'moving', name, 'to', new_path
    os.rename(name, new_path)
    return new_dir

def move_file(name):
    file_type = FileType.from_file(name)
##    print 'Moving', name, file_type
    if file_type == 'directory':
        #silently ignore
##        print name, 'is a directory, ignore it'
        return None

    if file_type.startswith('ASCII text') or file_type.startswith('Python script') or file_type.startswith('FORTRAN program'):
        return move_txt_file(name)
    elif file_type.startswith('Zip archive data'):
        return move_archive_file(name, zipfile.ZipFile)
    elif file_type.startswith('RAR archive data'):
        return move_archive_file(name, rarfile.RarFile)
    else:
        print name,'has wrong file type:', file_type
        return None

def move_all():
    """
    move all the files in current directory
    """
    moved = []
    notmoved = []
    for f in os.listdir('.'):
        result = move_file(f)
        if result != None:
            moved.append(result)
        else:
            notmoved.append(f)
    return [moved, notmoved]

def purge_osx_junks(root):
    """
    clean the junks generated by Mac OS X filesystem
    """
    for path, dirs, files in os.walk(root):
        if path.startswith('./'):
            path = path[2:]
        if path.find(OSX_JUNK_DIR) >= 0 or path.find(USED_ARCHIVE_DIR)>=0:
            continue
        purged_dir = os.path.join(OSX_JUNK_DIR, path)
        ensured = False
        for f in files+dirs:
            if f in OSX_JUNKS:
                oldpath = os.path.join(path, f)
                newpath = os.path.join(purged_dir, f)
                print oldpath, '->', newpath
                if not ensured:
                    ensure_path(purged_dir)
                    ensured = True
                os.rename(oldpath, newpath)

def flattern_dir(root):
    """
    for any directory, if it only contains a subdir and no files
    flattern it, move all the entries in the only subdir to the parent
    recursively does this
    """
    for path, dirs, files in os.walk(root):
        if path.startswith('./'):
            path = path[2:]
        if path.find(OSX_JUNK_DIR) >= 0 or path.find(USED_ARCHIVE_DIR)>=0:
            continue
        if len(files)==0 and len(dirs)==1:
            subdir = os.path.join(path, dirs[0])
            for f in os.listdir(subdir):
                oldpath = os.path.join(subdir, f)
                newpath = os.path.join(path, f)
                print oldpath, '->', newpath
                os.rename(oldpath, newpath)
            print 'rmdir', subdir
            os.rmdir(subdir)

PROB_NUM_RE = '(?:Problem\s*(?:Set)?|PS|PSet)\s*[1-2]\s*(?:[^a-zA-Z]*Question)?\s*([A-C]|\.[1-3])|Problem\s*([A-C1-3])'
PROB_NUM_MATCHER = re.compile(PROB_NUM_RE, flags=re.IGNORECASE)
def extract_num(comment):
    """
    extract problem number from a one line comment
    case-insensitive
    """

    def translate_num(num):
        if num.startswith('.'):
            num = num[1:]
        num = num.lower()
        if num>='a' and num<='c':
            return num
        elif num>='1' and num<='3':
            return chr(ord('a')+ord(num)-ord('1'))
        else:
            print 'Error! Invalid num', num, 'in line', comment
            assert False
            return None
            
    m = PROB_NUM_MATCHER.search(comment)
    if m != None:
        for num in m.groups():
            if num != None:
                num = translate_num(num)
                return num

    return None

def extract_prob_num(path):
    """
    extract the problem number from a source file "path"
    """
    with open(path) as infile:
        while True:
            line = infile.readline()
            if len(line) == 0:
                return None
            if line.startswith('#'):
                num = extract_num(line)
                if num != None:
                    return num
            else:
                if len(line.strip()) > 0:
                    return None

INFO_FILE_EXT = '.__Prob_Info__'
def get_all_prob_num(root):
    result = []
    no_prob_num = []
    for path, dirs, files in os.walk(root):
        for f in files:
            if f.find(INFO_FILE_EXT) < 0:
                fname = os.path.join(path, f)
                num = extract_prob_num(fname)
                if num == None:
                    print 'Cannot get prob num', fname
                    no_prob_num.append(fname)
                else:
                    result.append(fname)
                    info = fname + INFO_FILE_EXT
                    with open(info, mode='w') as outfile:
                        outfile.write(num)
    return [result, no_prob_num]
